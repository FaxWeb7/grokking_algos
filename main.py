# -------------- БИНАРНЫЙ ПОИСК -------------- #

# Бинарный поиск - алгоритм; на входе получает ОТСОРТИРОВАННЫЙ список элементов. Если элемент, который нужно найти, присутствует в списке, то бинарный поиск возвращает его позицию, его элемента нет - возвращает null

# Для того, чтобы посчитать максимальное количество шагов бинарного поиска, нужно найти логарифм числа элементов бинарного поиска (чтобы найти определенное число в массиве из 16 элементов, максимум понадобится log16 шагов, то есть 4)

# def binarySearch(list, item):
#     low = 0
#     high = len(list) - 1

#     while low <= high:
#         mid = (low + high) // 2
#         guess = list[mid]
#         if guess == item:
#             return mid
#         elif guess > item:
#             high = mid - 1
#         else:
#             low = mid + 1
#     return None
# list = [1, 3, 7, 8, 12, 20, 23, 28, 36]
# print(binarySearch(list, 23))


# -------------- МАССИВЫ И СВЯЗАННЫЕ СПИСКИ, СОРТИРОВКА ВЫБОРОМ -------------- #

# Массив - тип данных, все элементы которого хранятся в памяти непрерывно(рядом друг с другом, без пропусков).
# Для того, чтобы добавить дополнительный элемент в массив, нужно найти новое место в памяти, в котором поместятся все элементы текущего массива + новые элементы, без пропусков между ними

# Связанный список - тип данных, каждый элемент которого содержит ссылку на адрес в памяти следующего и/или предыдущего элемента списка.
# Таким образом, каждый элемент связанного списка может храниться в любых ячейках памяти, не обязательно друг рядом с другом. В связанный список можно без проблем добавлять дополнительные элементы без перезаписи всего списка, тк его элементы, опять же, могут храниться в любых ячейках памяти
# Минус связного списка в том, что не получится получить определенный элемент списка так же легко, как в массиве. Элементы списка хранятся в разных ячейках памяти, поэтому, чтобы определить индекс n-го элемента, нужно обратиться к первому элементу, чтобы получить адрес второго элемента, затем обратиться ко второму элементу  для получения адреса третьего - и так далее, пока не доберемся до n-го